#define SECURED /// 사용자가 정의한 기호. 만약 보안이 필요한 상황일때 전처리에서 프로그래머가 SECURED를 지정하면 컴파일할때 #if SECURED 코드에 작성한 코드가 포함된다.

using UnityEngine;
using System.Security.Cryptography;
using System.Text;

/// <summary>
/// 플레이어프랩스에 데이터를 저장하고, 가져오는 처리를하는 클래스. 전처리 옵션에 따라 암호화처리를 하고 푸는 처리를 한다.
/// </summary>
public static class SecurePlayerPrefs
{
    /// <summary>
    /// 플레이어프랩스에 게임에서 사용하는 데이터를 저장하는 메서드. 하나의 데이터를 원본과 체크 형태로 2개로 저장하고 둘다 암호화를 해서 저장한다.
    /// 보안 미적용: 프로그래머가 디파인에서 보안이 필요없다고 정의했을때는 플레이어프랩스에 그냥 키와 데이터를 저장한다. (이때는 암호화 안하고 저장한다)
    /// 보안 적용 : 저장할 하나의 키와 데이터를 2개 그룹(원본과체크) 으로 분리해서 암호화 처리해서 플레이어프랩스에 저장한다.플레이어프랩스는 보안성이 제로라서 하드웨어에서 그대로 데이터가 저장되어 노출된다. 
    /// 따라서 저장하는 원본을 여러가지 방법으로 암호화해도 누군가 원본데이터를 해킹해서 조작할 수 있는 우려가 있다. 이것을 방지하기 위해 여기서는 원본을 2개로 나누어서 하나는 암호화된 원본으로 저장하고, 하나는 체크데이터로 암호화를 한번 더 해서 저장한다.
    /// 이렇게 하면 누군가 위조하기 위해 플레이어프랩스 데이터에 접근해도, 뭐가 게임데이터인지 판별하기 어려울것이며, 둘 중 하나만 위조할 경우 플레이어프랩스에서 데이터를 꺼내올때 2개의 데이터가 서로 비교하는 시스템이기때문에 위조된 데이터가 게임에 반영되기 힘들것이며(둘다 위조 하면 어쩔수 없지만 ㅋㅋㅋ),  
    /// 이때 원본데이터라 함은 실제 게임에서 사용할 데이터를 암호화한것이고, 체크데이터라 함은 암호화된 원본데이터를 한번 더 암호화해서 나중에 플레이어프랩스에서 데이터를 꺼내올때 원본과 비교할때
    /// 원본데이터 : 
    ///     키 ->  MD5해시값으로 바꿔서 플레이어프랩스에 저장.
    ///     데이터 -> (프로그래머가 만든) 비트암호화메서드를 통해 암호화해서 플레이어프랩스에 저장.
    /// 체크데이터 :
    ///     키 -> 프로그래머가 의미없는 문자를 원래 키값에 결합 -> 그것을 MD5 해시 값으로 바꿔서 -> 플레이어프랩스에 저장. 
    ///     데이터 -> (프로그래머가 만든) 비트암호화메서드를 통해 암호화된 데이터를 -> MD5해시로 바꿔서 -> 한번 더 (프로그래머가 만든) 비트암호화메서드를 통해 암호화해서 -> 플레이어프랩스에 저장.
    /// </summary>
    /// <param name="저장키이름">플레이어프랩스에 저장할 키이름</param>
    /// <param name="저장데이터">플레이어프랩스에 저장할 데이터</param>
    public static void 플레이어프랩스에데이터저장(string 저장키이름, string 저장데이터)
	{
		#if (SECURED) /// 디파인을 보안이 필요한 경우로 지정한 경우 실행되는 코드 

        /// 플레이어프랩스에 저장할 원본의 키값과 데이터를 암호화해서 저장한다.
		string 저장키해시 = MD5해시생성 (저장키이름); // 저장키는 해시로 바꿔도 된다. 왜냐하면 플레이어프랩스에서 데이터를 불러오는 문자열이면 되기때문에 그게 해시 문자열이어도 상관없기때문이다.
		string 저장데이터비트 = 비트암호화또는풀기(저장데이터); // 주위 : 저장데이터는 해시로 절대 바꾸면 안된다. 왜냐하면 해시에서 원본데이터로 돌릴 수 없기때문이다.
        PlayerPrefs.SetString(저장키해시, 저장데이터비트);
        

        /// 플레이어프랩스에 저장할 체크의 키값과 데이터를 더 복잡하게 암호화해서 저장한다.
        /// 키값은 의미없는 글자를 덧붙여서 해시로 플레이어프랩스에 저장하고
        /// 데이터값은 위에서 비트암호화된것은 -> MD5해시로 만들고 -> 다시 또 이것을 비트암호화해서 플레이어프랩스에 저장한다.  
        string 체크키해시 = MD5해시생성 (저장키이름 + "asdf");
		string 체크데이터해시 = MD5해시생성 (저장데이터비트);
        string 체크데이터비트 = 비트암호화또는풀기 (체크데이터해시);
		PlayerPrefs.SetString (체크키해시, 체크데이터비트);
		
        #else /// 디파인을 보안이 필요하지 않은 상황으로 지정한 경우 실행되는 코드 
		
        /// 플레이어프랩스에 데이터를 저장한다.
        PlayerPrefs.SetString (저장키이름, 저장데이터);
		
        #endif
	}

    /// <summary>
    /// 플레이어프랩스에서 게임에서 사용하는 데이터를 가져오는 메서드. 암호화되어 저장된 원본과 체크 형태를 가져와서 비교한다음 데이터의 서로 같을 경우 원본데이터를 게임에서 사용할 수 있게 리턴해준다.
    /// 보안 미적용: 프로그래머가 디파인에서 보안이 필요없다고 정의했을때는 플레이어프랩스에 저장된 데이터를 가져온다. (암호화안된 데이터가 저장되어 있기때문에 그대로 가져와서 쓸수 있다)
    /// 보안 적용 : 플레이어프랩스에 암호화 처리되서 저장된 2개 그룹(원본과체크)의 데이터를 암호화를 풀어서 가져와서 비교한 위변조가 된게 없으면 원본데이터를 반환한다. 
    /// </summary>
    /// <param name="가져올데이터키이름">플레이어프랩스에서 데이터를 가져올때 사용할 키값</param>
    /// <returns></returns>
	public static string 플레이어프랩스에데이터가져오기(string 가져올데이터키이름)
	{
        #if (SECURED) /// 디파인을 보안이 필요한 경우로 지정한 경우 실행되는 코드 

        /// 플레이어프랩스에서 꺼내올 데이터의 키이름이 저장단계에서 해시값으로 만들어서 저장했기때문에, 불러올 키이름을 해시로 만들어 줘야 한다.  
        string 저장키해시 = MD5해시생성 (가져올데이터키이름);

        ///플레이어프랩스에 가져오고자하는 키값이 있는지 확인해보자. 있다면 해즈키 메서드가 true를 반환하기 때문에 이 조건문이 실행된다.
        if (PlayerPrefs.HasKey (저장키해시))
        {
            /// 가지고 올 데이터를 플레이어 프랩스에서 꺼내온다. 
            /// 이때 꺼내온 데이터는 저장단계에서 (프로그래머가 만든 비트암호화 메서드를 통해) 암호화된(알아볼수 없는 비트 숫자로 나열된) 상태이다. 
            /// 이것을 누가 건드려서 위변조 했는지를 검사하기 위해, 이 데이터와 체크데이터를 비교하기 위해 꺼내온 데이터도 해시로 바꾼다.
            /// 꺼내온 데이터를 해시로 바꾸는 이유는 암호화된 체크데이터를 해시단계까지 풀수있기때문이다.
            /// 즉 암호화된 체크데이터를 해시단계까지 풀수 있기때문에 꺼내온 데이터를 해시값으로 바꿔서 해시끼리 비교해 보는 방법을 쓰는 것이다.
            /// 주의 : 저장때 원본 데이터를 아예 해시로 바꿔서 저장하면 안된다. 해시는 다시 원본 데이터로 바꿀수 없기때문이다.
			string 저장데이터비트 = PlayerPrefs.GetString (저장키해시);
            string 저장데이터해시 = MD5해시생성(저장데이터비트);

            /// 플레이어프랩스에서 가져온 저장데이터가 위변조된게 없는지 체크할 체크데이터를(이것 역시 플레이어프랩스에 저장되어 있다) 가져오기 위해 먼저 체크키값을 해시로 만들어준다.
            /// 체크키값은 저장단계에서 무의미한 글자가 붙어서 해시로 만들어서 저장한 상태이기때문에, 꺼내올 체크키 값도 무의미한 글자를 붙여서 해시 상태로 만들어줘야 한다.
            /// 해시로 만든 체크키로 체크데이터를 꺼내온다.
            /// 이때 체크데이터는 저장단계에서 원본값이 비트암호화 -> 해시전환 -> 비트암호화되어서 저장되어 있기때문에 꺼내는 단계에서는 이것을 역순으로 해시까지 전환해야 한다. (해시에서 더 이상 역순으로 풀수는 없기때문에 해시단계까지만 풀어준다)
            string 체크키해시 = MD5해시생성 (가져올데이터키이름 + "asdf");
            string 체크데이터비트 = PlayerPrefs.GetString (체크키해시);
            string 체크데이터해시 = 비트암호화또는풀기 (체크데이터비트);
            
            /// 저장데이터와 체크데이터가 모두 동일하다면, 위변조된게 없다면
            if (string.Equals (저장데이터해시, 체크데이터해시))
            {
                /// (프로그래머가 만든) 비트암호화메서드로 암호화되어 저장된 데이터를 다시 풀어서 원본데이터로 만들어서 리턴한다.
                string 원본데이터 = 비트암호화또는풀기(저장데이터비트);
                return 원본데이터;
			}
            else /// 만약 데이터가 어긋난다면 (위변조된게 있다면) 빈 문자열을 리턴한다.
            {
				return "";
			}
		}
        else /// 플레이어프랩스에 가져오고자하는 키값이 없다면. 빈 문자열을 리턴한다.
        {
			return "";
		}

        #else /// 디파인을 보안이 필요하지 않은 상황으로 지정한 경우 실행되는 코드
        
        /// 플레이어프랩스에서 데이터를 가져온다.
        return PlayerPrefs.GetString (가져올데이터키이름);
        
        #endif
    }

    /// <summary>
    /// 플레이어프랩스에 float 타입의 데이터를 저장하는 메서드. 저장할때는 float -> string로 전환해서 저장한다.
    /// </summary>
    /// <param name="저장할키이름">플레이어프랩스에 저장할 키이름</param>
    /// <param name="저장데이터">플레이어프랩스에 저장할 데이터</param>
    public static void 저장float(string 저장할키이름, float 저장데이터)
    {
		플레이어프랩스에데이터저장 (저장할키이름, 저장데이터.ToString ());
	}

    /// <summary>
    /// 플레이어프랩스에 저장된 데이터중 부동소수점데이터(float)를 가져오기 위한 메서드이다.
    /// 만일 파라미터로 넣은 키값이 플레이어프랩스에 있고, 해당 되는 데이터가 float값이라면 해당 float값을 리턴하고, float타입 데이터가 아니라면 0을 리턴한다. 
    /// </summary>
    /// <param name="가져올데이터키이름">플레이어프랩스에서 데이터를 가져올때 사용할 키값</param>
    /// <returns></returns>
	public static float 얻기float(string 가져올데이터키이름)
    {
		float 가져온플로트데이터;
 
        if (float.TryParse (플레이어프랩스에데이터가져오기 (가져올데이터키이름), out 가져온플로트데이터))
        {
			return 가져온플로트데이터;
		}
        else
        {
			return 0f;
		}
	}

    /// <summary>
    /// 플레이어프랩스에 Double 타입의 데이터를 저장하는 메서드. 저장할때는 double -> string로 전환해서 저장한다.
    /// </summary>
    /// <param name="저장할키이름">플레이어프랩스에 저장할 키이름</param>
    /// <param name="저장할데이터">플레이어프랩스에 저장할 데이터</param>
	public static void 저장double(string 저장할키이름, double 저장할데이터)
    {
		플레이어프랩스에데이터저장 (저장할키이름, 저장할데이터.ToString ());
	}

    /// <summary>
    /// 플레이어프랩스에 저장된 데이터중 double타입을 가져오기 위한 메서드이다.
    /// 만일 파라미터로 넣은 키값이 플레이어프랩스에 있고, 해당 되는 데이터가 double값이라면 해당 double값을 리턴하고, double타입 데이터가 아니라면 0을 리턴한다.
    /// </summary>
    /// <param name="가져올데이터키이름">플레이어프랩스에서 데이터를 가져올때 사용할 키값</param>
    /// <returns></returns>
	public static double 얻기double(string 가져올데이터키이름)
    {
		double 가져온더블데이터;

        if (double.TryParse (플레이어프랩스에데이터가져오기 (가져올데이터키이름), out 가져온더블데이터))
        {
			return 가져온더블데이터;
		}
        else
        {
			return 0;
		}
	}

    /// <summary>
    /// 플레이어프랩스에 저장하는 데이터가 true이면, 1을 저장한다. false이면 0을 저장한다.
    /// </summary>
    /// <param name="저장할키이름">플레이어프랩스에 저장할 키이름</param>
    /// <param name="저장할데이터">플레이어프랩스에 저장할 데이터</param>
	public static void 저장Bool(string 저장할키이름, bool 저장할데이터)
    {
		if (저장할데이터)
        {
			저장int (저장할키이름, 1);
		}
        else
        {
			저장int (저장할키이름, 0);
		}
	}

    /// <summary>
    /// 플레이어프랩스에서 가져온 데이터가 1이면 true를 반환하고, 1이 아니면 false를 반환한다.  
    /// </summary>
    /// <param name="가져올데이터키이름">플레이어프랩스에서 가져올 데이터 키이름</param>
    /// <returns></returns>
	public static bool 얻기Bool(string 가져올데이터키이름)
    {
        if (얻기int(가져올데이터키이름) == 1)
        {
            return true;
        }
		return false;
	}

    /// <summary>
    /// 플레이어프랩스에 int 타입의 데이터를 저장하는 메서드. 저장할때는 int->string로 전환해서 저장한다.
    /// </summary>
    /// <param name="저장할키이름"></param>
    /// <param name="저장할데이터"></param>
    public static void 저장int(string 저장할키이름, int 저장할데이터)
    {
        플레이어프랩스에데이터저장(저장할키이름, 저장할데이터.ToString());
	}

    /// <summary>
    /// 플레이어프랩스에 저장된 데이터중 int타입을 가져오기 위한 메서드이다.
    /// 만일 파라미터로 넣은 키값이 플레이어프랩스에 있고, 해당 되는 데이터가 int값이라면 해당 int값을 리턴하고, int타입 데이터가 아니라면 0을 리턴한다.
    /// </summary>
    /// <param name="가져올데이터키이름"></param>
    /// <returns></returns>
	public static int 얻기int(string 가져올데이터키이름)
    {
		int 가져온인트데이터;

        if (int.TryParse(플레이어프랩스에데이터가져오기(가져올데이터키이름), out 가져온인트데이터))
        {
            return 가져온인트데이터;
        }
        else
        {
            return 0;
        }
	}

    /// <summary>
    /// 플레이어프랩스에 저장된 데이터중 string타입을 가져오기 위한 메서드이다.
    /// 만일 파라미터로 넣은 키값이 플레이어프랩스에 있다면 저장되어 있던 string타입의 데이터를 반환하고, 없다면 파라미터로 넣어준 디폴트문자를 반환한다.
    /// </summary>
    /// <param name="가져올데이터키이름"></param>
    /// <param name="디폴트문자"></param>
    /// <returns></returns>
	public static string 얻기String(string 가져올데이터키이름, string 디폴트문자)
	{
        if (키값존재여부(가져올데이터키이름))
        {
            return 플레이어프랩스에데이터가져오기(가져올데이터키이름);
        }
        else
        {
            return 디폴트문자;
        }
	}

    /// <summary>
    /// 파라미터로 받은 값이 플레이어프랩스에 이미 존재하는 키값인지 확인해서 존재하면 true를, 존재하지 않으면 false를 반환한다.
    /// </summary>
    /// <param name="키값">플레이어프랩스에 키값이 있는지 검사할 키값</param>
    /// <returns></returns>
	public static bool 키값존재여부(string 키값)
	{
		#if(SECURED) /// 전처리기 지시문에서 프로그래머가 보안이 필요한 상황이라고 작성했다면 처리되는 코드
        /// 파라미터로 입력받은 값을 MD5 해시값으로 바꿔서 저장
		string 해시로바꾼키값 = MD5해시생성 (키값);
        /// MD5로 바꾼값이 플레이어프랩스에 존재하는 지를 확인한다
		bool 키값존재 = PlayerPrefs.HasKey (해시로바꾼키값);
        /// 확인한 값을 리턴한다.
		return 키값존재;
        #else /// 전처리기 지시문에서 프로그래머가 보안이 필요하지 않은 상황으로 작성했다면 처리되는 코드
        /// 파라미터로 입력받은 값이 플레이어프랩스에 존재하는지를 확인한다.
		bool 키값존재 = PlayerPrefs.HasKey (키값);
        /// 확인한 값을 리턴한다.
		return 키값존재;
        #endif
    }

#if (SECURED) /// 보안이 필요한 경우라면.

    /// 비트 연산을 통해 이진수 숫자를 흩트려놓기 위한 그냥 프로그래머가 넣은 아무 숫자. xor 암호를 하기 위해.
    /// 이진수차원에서 이값과 비트연산을 통해 원래 값을 흩트려놓기 때문에 다른 사람이 이값을 알지 못하면 다시 비트 연산을 한다고 해도 원래 글자를 알수 없을 것이다.
    public static int 아무숫자 = 129;

    /// <summary>
    /// 프로그래머가 만든 입력받은 값을 XOR비트 암호화하거나 다시 푸는 메서드.
    /// 문자를 파라미터로 입력받아서, 파라미터로 입력받은 문자값을 아무 숫자를 이용해서 XOR 비트연산해서, 이진수 차원에서 파라미터로 입력받은 값을 흩트려놓아서, 리턴하는 값은 전혀 다른 값을 내놓게 되는 메서드이다.
    /// 즉, 
    /// 본 메서드를 암호화하는데 사용한다면, 원래 값을 프로그래머가 정한 아무숫자를 이용해서 흩트려놓은 값을 반환해서 암호화가 된다. 
    /// 반대로 본 메서드를 통해 흩트려놓은 값을 다시 본 메서드의 파라미터 값으로 집어넣으면 원래 값으로 다시 환원된다.
    /// </summary>
    /// <param name="텍스트"></param>
    /// <returns>암호화된 값</returns>
    public static string 비트암호화또는풀기(string 텍스트)
    {
        /// 스트링빌더 객체를 2개 만드는데,
        /// 한개는 파라미터로 받는 텍스트를 저장할 스트링빌더 객체고
        /// 한개는 위 객체와 동일한 크기의 반환값을 저장할 스트링빌더 객체를 만든다.
		StringBuilder 들어오는스트링빌더객체 = new StringBuilder (텍스트);
		StringBuilder 나가는스트링빌더객체 = new StringBuilder (텍스트.Length);
        
        /// 문자를 넣을 로컬 변수
		char 문자;
        
        /// 파라미터의 입력받은 텍스트 길이만큼 루프를 돌면서
		for (int i = 0; i < 텍스트.Length; i++)
        {
            /// 파라미터로 입력받은 텍스트를 한글짜씩 떼어서 할당
            문자 = 들어오는스트링빌더객체[i];

            /// 아무숫자값이 십진수 129이니깐 이진수로는 10000001이다. 이것을 2진수 자리수로 대입해서 현재 로컬변수에 들어 있는 값이 같으면 0, 서로 다른값이면 1을 반환해서 그걸 텍스트로 전환해서 넣는다.
            문자 = (char)(문자 ^ 아무숫자);

            /// 밖으로 뽑는 스트링 빌더값에 계속 추가한다.
            나가는스트링빌더객체.Append(문자);
        }
        /// 이진수가 흩트려진 값(프로그래머가 임의로 암호한 값)을 반환한다. 문자열
		return 나가는스트링빌더객체.ToString ();
	}

    /// <summary>
    /// 파라미터로 입력한 텍스트를 한글자씩 쪼개서, 쪼개진 한글자씩을 MD5 해시값으로 바꿔서 쭈욱 붙여서 문자열로 만들어서 리턴하는메서드.
    /// MD5 해시 방식이 아주 안전하지 않기때문에 비밀번호 저장방식으로는 안전하지 않기때문에 비밀번호 용도로는 쓰지 말것.
    /// </summary>
    /// <returns>MD5 해시 문자열</returns>
    /// <param name="해시값으로바꿀텍스트">해시값으로 바꿀 텍스트</param>
    static string MD5해시생성(string 해시값으로바꿀텍스트)
	{
        /// step 1, 씨샵에서 제공하는 MD5 해시 알고리즘 타입의 해시 객체를 할당한다.
		var md5객체 = MD5.Create();

        /// UTF8 인코딩 방식으로 파라미터로 받은 텍스트를 한글자씩 쪼개서 바이트로 변환해서 할당.
		byte[] 바이트로쪼갠문자 = Encoding.UTF8.GetBytes(해시값으로바꿀텍스트);
        /// 한글자씩 쪼갠 바이트를 해시값으로 변환해서 배열에 한개씩 할당.
		byte[] 해시 = md5객체.ComputeHash(바이트로쪼갠문자);

		/// step 2, 해시값이 담긴 배열을 루프를 돌면서 16진수 문자열로 변경
		var 리턴값 = new StringBuilder();

        for (int i = 0; i < 해시.Length; i++)
		{
            /// 해시 배열을 16진수값으로 바꾼다.
			리턴값.Append(해시[i].ToString("X2"));
		}

        /// 생성된 해시 문자열을 반환.
		return 리턴값.ToString();
	}

	#endif
}